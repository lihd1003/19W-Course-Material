<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />

<title>Greedy Algorithm - Notes Portal</title>

<link rel="icon" type="image/gif" href="https://lihd1003.github.io/assets/images/logo.png">
<link rel="stylesheet" href="https://lihd1003.github.io/assets/css/vendor.css" />
<link rel="stylesheet" href="https://lihd1003.github.io/assets/css/style.css" />
<link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
<script src="https://kit.fontawesome.com/98fa07784c.js"></script>



<style type="text/css">
/* Overrides of notebook CSS for static HTML export */

div#notebook {
  overflow: visible;
  border-top: none;
}@media print {
  div.cell {
    display: block;
    page-break-inside: avoid;
  } 
  div.output_wrapper { 
    display: block;
    page-break-inside: avoid; 
  }
  div.output { 
    display: block;
    page-break-inside: avoid; 
  }
}
</style>

<!-- Custom stylesheet, it must be in the same directory as the html file -->
<link rel="stylesheet" href="https://lihd1003.github.io/UofT-Course-Material-Repo/index/custom.css">

<!-- Loading mathjax macro -->
<!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration --></head>
<body>
	<!-- header -->
   <header class="header-sticky header-dark">
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-dark">
        <a class="navbar-brand" href="./index.html">
          <img class="navbar-logo navbar-logo-light" src="https://lihd1003.github.io/assets/images/logo.png" alt="Logo">
          <img class="navbar-logo navbar-logo-dark" src="https://lihd1003.github.io/assets/images/logo.png" alt="Logo">
        </a>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav align-items-center mr-auto">
          </ul>

          <ul class="navbar-nav align-items-center mr-0">
            <li class="nav-item">
              <a href="https://github.com/lihd1003" class="nav-link waves-effect waves-light" target="_blank">
                <i class="icon-github mr-2"></i>GitHub
              </a>
            </li>
            <li class="nav-item">
              <a href="https://github.com/lihd1003/UofT-Course-Material-Repo" class="nav-link waves-effect waves-light" target="_blank">
                <i class="icon-star mr-2"></i>Star the Repo
              </a>
            </li>
          </ul>
        </div>
      </nav>
    </div>
  </header>

<section class="hero hero-with-header text-white" data-top-top="transform: translateY(0px);" data-top-bottom="transform: translateY(250px);">
    <div class="image image-overlay" style="background-image:url(https://lihd1003.github.io/assets/images/black.jpg)"></div>
    <div class="container">
      <div class="row align-items-center">
        <div class="col text-shadow">

          <h1 class="mb-0">Greedy Algorithm</h1>
        </div>
      </div>
    </div>
 </section>
 <section class="bg-white sec" id="project">
  <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Greedy-Algorithm">Greedy Algorithm<a class="anchor-link" href="#Greedy-Algorithm">&#182;</a></h2><hr>
<h4 id="Activity-Schedule">Activity Schedule<a class="anchor-link" href="#Activity-Schedule">&#182;</a></h4><p>$A = \{a_1,...,a_n\}$ set of tasks, $|A|=n$, $a_i = (s_1,f_i), s_i=$ start time, $f_i=$ finish time. $S \subseteq A. S=$ set of tasks without overlap. Maximize $|S|$. <br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em><strong>Implementation</strong></em> Greedy based on finish time <br></p>
<div class="highlight"><pre><span></span><span class="mi">1</span>  <span class="n">sort</span> <span class="n">A</span> <span class="n">by</span> <span class="n">the</span> <span class="n">finishing</span> <span class="n">time</span>
<span class="mi">2</span>  <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># finishing time</span>
<span class="mi">3</span>  <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
<span class="mi">4</span>  <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span> 
<span class="mi">5</span>      <span class="k">if</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">ai</span><span class="o">.</span><span class="n">s</span><span class="p">:</span> <span class="c1"># the start time of the ith activity</span>
<span class="mi">6</span>          <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
<span class="mi">7</span>          <span class="n">f</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">f</span>
<span class="mi">8</span>  <span class="k">return</span> <span class="n">S</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em><strong>Correctness</strong></em>  Thrm 16.1 CLRS<br>
Define $OPT\subseteq A$ be an optimal solution of the problem, in which $|OPT|$ is maximized and there is no overlapping in $OPT$.<br>
Define $S_k$ be the state of $S$ after the $k$th iteration of the for loop (4-7), $S_0$ be the state before entering the loop.<br>
<strong><em>Claim</em></strong> $\exists OPT. \forall k\in\mathbb{N}.S_k\subseteq OPT\subseteq S_k\cup\{A_{k+1},...,A_n\}$. (loop invariant)<br> 
<strong><em>Proof</em></strong> prove by induction <br>
<em>Base case</em> $S_0=\emptyset\subseteq OPT\subseteq \{A_1,...,A_n\}$ <br>
<em>Inductive step</em> Take $OPT$ be some optimal solution,assume the inductive hypothesis. Consider the two cases</p>
<ul>
<li>$S_{i+1} = S_i$, a.k.a. $A_{k+1}$ overlaps with some activity in $S_{i}$. By induction hypothesis, $S_{i+1}\subseteq OPT\subseteq S_k \cup \{A_{k+1},..., A_n\}=S_{k+1}\cup \{A_{k+1},..., A_n\}$. Moreover, $A_{k+1}\not\in OPT$ because $A_{k+1}$ would overlap with some activity in $OPT$, hence $S_{i+1}\subseteq OPT\subseteq S_{k+1}\cup \{A_{k+1},..., A_n\} - \{A_{k+1}\} = S_{k+1}\cup \{A_{k+2},..., A_n\}$. </li>
</ul>
<ul>
<li>$S_{i+1} = S_{i}\cup \{A_{k+1}\}$. <br>
If $A_{k+1}\in OPT$, then the claim is proven. <br>
If $A_{k+1}\not\in OPT$, then consider $A_m\in OPT, m &gt; i+1$ is the smallest index that is greater than $i+1$, then $A_m$ has greater finishing time than $A_{k+1}$, let $OPT' = OPT - {A_m} \cup \{A_{i+1}\}, |OPT'|=|OPT|$, $A_{k+1}$ will not overlap with any other activities in $OPT'$ since it will not overlap with any activities before $A_m$ by its starting time property, and it will not overlap with any activity after $A_m$ since it even finishes earlier than $A_m$, then $OPT'$ is a optimal solution, and $S_{k+1}\subseteq OPT'$ since $m &gt; i+1, A_m\not\in S_{k+1}$, and $OPT' \subseteq S_{k+1}\cup\{A_{k+2},...,A_n\}$ since $A_{k+1}\in S_{k+1}$</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong><em>General strategy for proving Greedy correctness</em></strong> every <em>partial solution</em> generated can be <em>extended</em> to an <em>optimal solution</em> <br></p>
<p>Proof of sub-case 2.2 is called <em>exchange lemma</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Minimal-Spanning-Tree">Minimal Spanning Tree<a class="anchor-link" href="#Minimal-Spanning-Tree">&#182;</a></h4><p>Let $G=(V,E)$ be a connected graph with weight function $w(e)\in\mathbb{N}. \forall e\in E$. <br>
A Spanning tree $S = (V,T)$ is an acyclic, connected subgraph (tree) of $G$.<br>
minimize $w(T)=\sum_{e\in T}w(e)$</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em><strong>Implementation</strong></em></p>
<ul>
<li><em>Prim's Algorithm</em> Start with an arbitrary vertex $v$, let $C = \{v\}$ be the connected component. For each iteration, add the shortest edge attaches to $C$ and some $u\not\in C$, until $C = V$. </li>
<li><em>Kruskal's Algorithm</em> Start with $T = \emptyset$, let $E'$ be $E$ sorted in non-increasing order of weight. Iterate over $E'$, if $e$ connects two different connected component (implement with disjoint set), adds to $T$. <div class="highlight"><pre><span></span><span class="n">krustal_mst</span><span class="p">():</span>
<span class="mi">1</span> <span class="n">sort</span> <span class="n">E</span> <span class="n">by</span> <span class="n">non</span><span class="o">-</span><span class="n">increasing</span> <span class="n">order</span>
<span class="mi">2</span> <span class="n">T</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#empty disjoint set</span>
<span class="mi">3</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
<span class="mi">4</span>     <span class="k">if</span> <span class="n">e</span> <span class="n">connects</span> <span class="n">two</span> <span class="n">disjoint</span> <span class="n">sets</span><span class="p">:</span>
<span class="mi">5</span>         <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</li>
<li><em>Reverse remove Algorithm</em> Starts with $T = E$, let $E'$ be $E$ sorted in non-decreasing order of weight, iterate over $E'$, remove $e$ from $T$ if the two vertices are still connected. </li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em><strong>Correctness (Krustal's)</strong></em> <br>
Define $T_i$ be the state of $T$ after the $i$th iteration of the for loop (line 3-5), $T_0=\emptyset$. Define $T^*$ be the optimal solution.<br>
<strong>Claim</strong> $\forall n\in\mathbb{N}. T_n\subseteq T^*\subseteq T_n\cup\{e_{n+1},...,e_{m}\}$ <br>
<strong>Proof</strong> Let $n\in\mathbb{N}$.<br>
Suppose $n = 0$, $\emptyset\subseteq T^* \subseteq E$. <br>
Suppose $n &gt; 0$, assume $P(n)$. <br></p>
<ul>
<li>Suppose $T_{n+1} = T_{n}$, then by the if condition (line 4), $e_{n+1}$ will create a cycle in $T_n$, hence $e_{n+1}\not\in T^*$. Therefore, $T_{n+1} = T_n \subseteq T^* \subseteq T_{n+1}\cup\{e_{n+2},...,e_m\}$</li>
<li>Suppose $T_{n+1} = T_{n}\cup\{e_{n+1}\}$ <br>
If $e_{n+1} \in T^*$, then proven <br>
If $e_{n+1}\not\in T^*$, say $e_{n+1} = (u, v),u\in T_n, v\not\in T_n$, then consider some $e_i\in T^*$ with one endpoint being $v$, $e_i\not\in T_n$ since $T_n$ does not connect $v$. Then, $w(e_i)\geq w(e_{n+1})$ by the sorting property. Then consider $T^{**} = T^* - \{e_i\}\cup\{e_{k+1}\}, w(T^{**})\leq w(T^*)$. Also, $T^{**}$ is connected, acyclic by the MST property of $T^*$. Hence $T^{**}$ is a MST. $T_{n+1}\subseteq T^{**}\subseteq T^{**}\cup \{e_{n+2},...,e_m\}$. </li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Shortest-Path">Shortest Path<a class="anchor-link" href="#Shortest-Path">&#182;</a></h4><p><strong>Precondition</strong> $G = (V,E)$ connected, with $w:E\rightarrow \mathbb{Z}^+$. $s,t\in V$ <br>
<strong>Postcondition</strong> return $u\sim v$ with minimized $w(u\sim v) = \sum_{e\in u \sim v} w(e)$</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em><strong>Implementations</strong></em></p>
<ul>
<li>Brute force: worst case $O(c^n)$</li>
<li>Special Case: $\forall e\in E. w(e) = 1\Rightarrow $ BFS $\in O(|E|)$</li>
<li><p>Dijkstra's Algorithm</p>
<div class="highlight"><pre><span></span><span class="n">dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
  <span class="mi">1</span>     <span class="n">P</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of edges of the shortest paths tree</span>
  <span class="mi">2</span>     <span class="n">Q</span> <span class="o">=</span> <span class="n">empty</span> <span class="nb">min</span><span class="o">-</span><span class="n">priority</span> <span class="n">queue</span> <span class="n">of</span> <span class="n">vertices</span> <span class="n">v</span><span class="p">,</span> <span class="n">prioritize</span> <span class="n">on</span> <span class="n">v</span><span class="o">.</span><span class="n">d</span>
  <span class="mi">3</span>     <span class="k">for</span> <span class="nb">all</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
  <span class="mi">4</span>         <span class="n">v</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">Nil</span>
  <span class="mi">5</span>         <span class="n">v</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">Infinity</span>
  <span class="mi">6</span>         <span class="n">Q</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="mi">7</span>     <span class="n">s</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="mi">8</span>     <span class="n">Q</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

  <span class="mi">9</span>     <span class="k">while</span> <span class="n">Q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
  <span class="mi">10</span>        <span class="n">v</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>
  <span class="mi">11</span>        <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">parent</span><span class="p">))</span>
  <span class="mi">12</span>        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">all</span> <span class="n">paths</span> <span class="n">containing</span> <span class="n">v</span><span class="p">:</span>
  <span class="mi">13</span>            <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Q</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">d</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">u</span><span class="o">.</span><span class="n">d</span><span class="p">:</span>
  <span class="mi">14</span>                <span class="n">u</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">v</span>
  <span class="mi">15</span>                <span class="n">u</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">d</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
  <span class="mi">16</span>                <span class="n">Q</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
  <span class="mi">17</span>    <span class="n">P</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">Nil</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
  <span class="mi">18</span>    <span class="k">return</span> <span class="n">p</span>
</pre></div>
<ul>
<li>Similar to BFS, use a priority queue (prioritized by best distance so far) instead of an array</li>
<li>Similar to Prim's, but with different priorities</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em><strong>Runtime</strong></em> <br>
$O((m+n)\log n) = O(m \log n)$ since connected
Initialization takes (1-8) $O(n)$ time <br>
Consider the while loop (9-16), in each iteration, $v$ is dequeued from $Q$ and no nodes are enqueued, hence the while loop will execute $O(n)$ time. <br>
Consider the inner for loop, consider $G$ implemented as an adjacency list. Over all iterations, each edge generates at most one queue update and are examined at most twice. For each queue update, it takes $O(\log n)$ time. Therefore, the total is $O(m\log n)$
Since the graph is connected, the total time is $O(m \log n)$</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em><strong>Properties</strong></em><br>
Define $\forall v\in V. \delta (s,v)=\min\{w(s\sim v)\mid s\sim v\text{ is a path in }G\}$ <br></p>
<p><strong>Lemma 1</strong> $\forall v\in V$. in any iteration, $v.d\geq \delta(s,v)$.<br>
<strong>Proof</strong> by induction on the number of iteration, based on the algorithm, $u.d=\infty$ or weight of some particular path.<br></p>
<p><strong>Lemma 2</strong> (Triangular property) $\forall u,v,w\in V. \delta(u,v)\leq \delta(u,w)+\delta(w,v)$.<br>
<strong>Proof</strong> Otherwise $u\sim w\sim v$ is the shortest path.</p>
<p><strong>Lemma 3</strong> (sub-path property) Any sub-path of a shortest path is shortest. <br>
<strong>Proof</strong> prove by contradiction, a shorter sub-path will shorten the path.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em><strong>Discussion</strong></em><br>
Show $P_k$ the value of $P$ after the $k$th iteration of the loop, can be extend to some optimal shortest path tree.</p>
<ul>
<li>Core of inductive step: show that $\forall v\in P_k. v.d=\delta(s,v)$</li>
<li>Consider one iteration $P_{k+1}=P_k\cup\{v'.parent, v'\}$ which $v'$ is just being connected. Then it follows $v'.d=\delta(s,v')$. <br>
By lemma 1, we only need to prove $u.d \leq \delta(s,v)$ by contradiction. <br>
Assume $v.d&gt;\delta(s,v)$. Consider $s\sim v\in P_{k+1}$, consider $(s\sim v)^*$ be the shortest path, let $(x,y)\in(s\sim v)^*$ be the first edge such that $x\in P_k, y\not\in P_k$. <br>
If $y\neq v$, then 
$y.d \leq x.d + w(x,y)\leq \delta(s,x)+w(x,y)&lt;\delta(s,x)+w(x,y)+\delta(y,v)=\delta(s,v)&lt;v.d$, contradict to $v.d$ is the min in $Q$<br>
If $y=v,v.d\leq x.d+w(x,v)=\delta(s,v)&lt;v.d$</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em><strong>Correctness</strong></em> <br>
Let $k\in\mathbb{N}. k &lt; n$. Let $P(k)$ be such that "$\exists P^*$ be the optimal solution s.t. $P_k\subseteq P^*$ and $P^*-P_k$ contains only edges without both endpoints in $P_k$ and $\forall u\in P_k.\forall v\not\in P_k. u.d=\delta(s,u)\leq \delta(s,v)\leq v.d$".</p>
<p>Suppose $k = 0$, $P_0=\emptyset\subseteq P^*$.</p>
<p>Suppose $k &gt; 0$, assume $P(k)$. consider $P_{k+1} = P_k \cup \{(u,v)\}, u\in P_k, v\not\in P_k$.</p>
<ul>
<li>Suppose $(u,v)\in P^*$. Then $P_{k+1}\subseteq P^*$. Also $\delta(s,v)=\delta(s,u)+w(u,v)=\delta(s,v)$. By the priority of $Q$, $v.d$ is the smallest among vertices not connected by $P_k$, hence $\forall x\in P_{k+1}.\forall w\not\in P_{k+1}. x.d\leq \delta(s,x)\leq \delta(s,w)\leq w.d$.</li>
<li>Suppose $(u,v)\not\in P^*$. Then take $(s\sim v)^* \in P^*$, $(w,v)$ be the last edge in the path $(s\sim v)^*$. <br>
I claim that $w\in P_k$. <br><ul>
<li>Let $(x,y)\in(s\sim v)^*$ be the first edge such that $x\in P_k, y\not\in P_k$. Then $y.d\le \delta(s,v) \leq v.d$ because $w((s,v)^*)=\delta(s,v)$ and $w(s\sim y) &lt; w((s,v)^*)$ since $y$ is on the path. However this contradict with the fact that $v.d$ has the minimum priority. </li>
</ul>
</li>
<li>Therefore, $\delta(s,v) = w.d + w(w,v)$. Then, since $v.d$ is the shortest distance, $v.d \leq w.d + w(w,v) = \delta(s,v)$. By Lemma 1, $v.d = \delta(s,v)$ <br>.
Take $P^{**} = P^* - \{(w,v)\}\cup\{(u,v)\}$ is a shortest path tree and $\forall x\in P_k. \forall y\not\in P_k. x.d = \delta(s,x)\leq \delta(s,y) \leq y.d$</li>
</ul>

</div>
</div>
</div>
    </div>
  </div>
</section>
  <script src="https://lihd1003.github.io/assets/js/vendor.js"></script>
  <script src="https://lihd1003.github.io/assets/js/app.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script>
    $("table").addClass("table table-lined")
  </script>
</body>

 


</html>
